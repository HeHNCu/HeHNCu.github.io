---
sidebarDepth: 4
---
# P2602 [ZJOI2010] 数字计数

## 题面

### 题目描述

给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。

### 输入格式

仅包含一行两个整数 $a,b$，含义如上所述。

### 输出格式

包含一行十个整数，分别表示 $0\sim 9$ 在 $[a,b]$ 中出现了多少次。

### 样例 #1

#### 样例输入 #1

```
1 99
```

#### 样例输出 #1

```
9 20 20 20 20 20 20 20 20 20
```

### 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a\le b\le10^6$；
- 对于 $100\%$ 的数据，保证 $1\le a\le b\le 10^{12}$。


## 思路

先考虑暴力，直接从 $[a,b]$ 硬搜即可

```cpp
#include<iostream>
#include<vector>
using namespace std;
typedef long long ll;
ll sum[10],ed,srt;
void dfs(ll x){
	if(x<srt)return;
	dfs(x-1);
	while(x){
		sum[x%10] ++ ;
		x /= 10;
	}
} 
int main(){
	cin>>srt>>ed;
	dfs(ed);
	for(int i=0;i<10;i++)cout<<sum[i]<<' ';
}
```
当然，时间复杂度肯定是会超的，必须考虑优化
---
当然，状态转移方程很好设

设 $f_{i,j,k}$ 表示构建长度为 $i$ 的整数，其最高位为 $j$， $k$ 编码出现的总次数.

当然，对于数位 $dp$，肯定要先处理 $10^n(n \le 12)$ 次方的.
```cpp
ll power[13];
void init() {
	power[0] = 1;
	for(int i=2;i<=12;i++)power[i] = power[i-1] * 10;
}
```

首先，$f_{i,j,j}$ 肯定是等于 $10^{i-1}$ 的，不会的回小学学去.

那么就可以推出 $f_{i,j,n} = \sum_{k=0}^9 f_{i-1,k,n}$.